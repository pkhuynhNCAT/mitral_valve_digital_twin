<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, viewport-fit=cover"
  />
  <meta
    name="description"
    content="MitralViz Pro™ - Advanced Cardiac Digital Twin System (Educational/Research)"
  />
  <meta name="author" content="MitralViz Pro Medical Systems" />
  <title>MitralViz Pro™ - Advanced Cardiac Digital Twin System v4.0</title>

  <!-- ====== STYLE (kept & extended) ===================================== -->
  <style>
    /* (Most of your original CSS stays. A few small additions below.) */
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    :root{
      --font-stack: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
      --primary-gradient: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
      --secondary-gradient: linear-gradient(135deg,#f093fb 0%,#f5576c 100%);
      --tertiary-gradient: linear-gradient(135deg,#4facfe 0%,#00f2fe 100%);
      --dark-bg:#0a0e27;--panel-bg:rgba(15,20,40,.95);--glass-bg:rgba(255,255,255,.03);--glass-hover:rgba(255,255,255,.06);
      --border-color:rgba(100,150,255,.15);--border-hover:rgba(100,150,255,.3);
      --text-primary:#e8eaf6;--text-secondary:#9499b7;--text-tertiary:#6b7294;
      --accent-blue:#4a9eff;--accent-purple:#9945ff;--accent-pink:#ff45a1;--accent-cyan:#00d4ff;
      --success:#00d68f;--warning:#ffaa00;--danger:#ff3d71;--info:#00b8d4;
      --shadow-sm:0 2px 4px rgba(0,0,0,.1);--shadow-md:0 4px 12px rgba(0,0,0,.15);
      --shadow-lg:0 8px 24px rgba(0,0,0,.2);--shadow-xl:0 12px 48px rgba(0,0,0,.3);--shadow-glow:0 0 40px rgba(102,126,234,.3);
      --transition-fast:150ms cubic-bezier(.4,0,.2,1);--transition-base:250ms cubic-bezier(.4,0,.2,1);--transition-slow:350ms cubic-bezier(.4,0,.2,1);--transition-spring:500ms cubic-bezier(.34,1.56,.64,1);
    }

    body{font-family:var(--font-stack);background:var(--dark-bg);
      background-image:radial-gradient(ellipse at top left,rgba(102,126,234,.15) 0%,transparent 40%),
                        radial-gradient(ellipse at bottom right,rgba(240,147,251,.15) 0%,transparent 40%),
                        radial-gradient(ellipse at center,rgba(79,172,254,.1) 0%,transparent 60%);
      color:var(--text-primary);overflow:hidden;height:100vh;position:relative;user-select:none;}

    .bg-particles{position:fixed;inset:0;pointer-events:none;z-index:0;opacity:.4;}
    .particle{position:absolute;width:2px;height:2px;background:var(--accent-blue);border-radius:50%;animation:float 20s linear infinite;}
    @keyframes float{from{transform:translateY(100vh) translateX(0);opacity:0;}10%{opacity:1;}90%{opacity:1;}to{transform:translateY(-100vh) translateX(100px);opacity:0;}}

    .app-container{display:grid;grid-template-columns:400px 1fr 440px;grid-template-rows:75px 1fr 130px;height:100vh;gap:1px;background:rgba(100,150,255,.05);position:relative;z-index:1;}
    .header{grid-column:1/-1;background:linear-gradient(135deg,rgba(15,20,40,.98) 0%,rgba(25,30,50,.98) 50%,rgba(15,20,40,.98) 100%);backdrop-filter:blur(20px) saturate(180%);display:flex;align-items:center;justify-content:space-between;padding:0 30px;border-bottom:1px solid var(--border-color);box-shadow:var(--shadow-lg);position:relative;overflow:hidden;}
    .header::before{content:'';position:absolute;top:0;left:-100%;width:200%;height:2px;background:var(--primary-gradient);animation:scanline 3s linear infinite;}
    @keyframes scanline{to{left:100%;}}
    .logo-section{display:flex;align-items:center;gap:20px;}
    .logo{width:50px;height:50px;background:var(--primary-gradient);border-radius:14px;display:flex;align-items:center;justify-content:center;position:relative;box-shadow:var(--shadow-glow);animation:pulse 2s infinite;cursor:pointer;transition:transform var(--transition-spring);}
    .logo:hover{transform:rotate(10deg) scale(1.1);}
    .logo-icon{font-size:28px;animation:heartbeat 1.5s ease-in-out infinite;}
    @keyframes heartbeat{0%,100%{transform:scale(1);}25%{transform:scale(1.1);}45%{transform:scale(.9);}}
    @keyframes pulse{0%,100%{box-shadow:0 0 20px rgba(102,126,234,.4),0 0 40px rgba(102,126,234,.2);}50%{box-shadow:0 0 30px rgba(102,126,234,.6),0 0 60px rgba(102,126,234,.3);}}
    .logo-text{display:flex;flex-direction:column;}
    .logo-title{font-size:24px;font-weight:700;background:var(--primary-gradient);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;letter-spacing:-.5px;}
    .logo-subtitle{font-size:11px;color:var(--text-secondary);text-transform:uppercase;letter-spacing:1.5px;margin-top:2px;opacity:.8;}
    .header-nav{display:flex;gap:12px;}
    .nav-btn{padding:12px 24px;background:var(--glass-bg);border:1px solid var(--border-color);border-radius:12px;color:var(--text-secondary);cursor:pointer;transition:all var(--transition-base);font-size:13px;font-weight:500;position:relative;overflow:hidden;font-family:var(--font-stack);}
    .nav-btn::before{content:'';position:absolute;top:50%;left:50%;width:0;height:0;background:var(--primary-gradient);border-radius:50%;transform:translate(-50%,-50%);transition:all var(--transition-slow);}
    .nav-btn:hover{color:#fff;border-color:var(--border-hover);transform:translateY(-2px);box-shadow:var(--shadow-lg);}
    .nav-btn:hover::before{width:300px;height:300px;}
    .nav-btn span{position:relative;z-index:1;}
    .nav-btn.active{background:var(--primary-gradient);color:#fff;border-color:transparent;box-shadow:var(--shadow-glow);}
    .header-status{display:flex;align-items:center;gap:12px}
    .status-indicator{display:flex;align-items:center;gap:10px;padding:10px 18px;background:rgba(0,214,143,.1);border:1px solid rgba(0,214,143,.3);border-radius:25px;transition:all var(--transition-base);}
    .status-dot{width:10px;height:10px;background:var(--success);border-radius:50%;box-shadow:0 0 10px var(--success);animation:blink 2s infinite;}
    @keyframes blink{0%,100%{opacity:1;transform:scale(1);}50%{opacity:.6;transform:scale(.8);}}
    .status-text{font-size:12px;color:var(--success);font-weight:600;text-transform:uppercase;letter-spacing:.5px;}

    .left-panel{background:linear-gradient(180deg,var(--panel-bg) 0%,rgba(20,25,45,.98) 100%);backdrop-filter:blur(20px);border-right:1px solid var(--border-color);overflow:auto;padding:30px 25px;position:relative;}
    .right-panel{background:linear-gradient(180deg,var(--panel-bg) 0%,rgba(20,25,45,.98) 100%);backdrop-filter:blur(20px);border-left:1px solid var(--border-color);overflow:auto;padding:30px 25px;position:relative;}
    .section{margin-bottom:35px;animation:slideInLeft .5s ease both;}
    .section:nth-child(1){animation-delay:.1s}.section:nth-child(2){animation-delay:.2s}.section:nth-child(3){animation-delay:.3s}.section:nth-child(4){animation-delay:.4s}
    @keyframes slideInLeft{from{opacity:0;transform:translateX(-30px);}to{opacity:1;transform:translateX(0);}}
    .section-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:20px;}
    .section-title{font-size:13px;font-weight:600;text-transform:uppercase;letter-spacing:1.5px;color:var(--text-secondary);display:flex;align-items:center;gap:12px;}
    .section-title::before{content:'';width:4px;height:20px;background:var(--primary-gradient);border-radius:2px;animation:glow 2s ease-in-out infinite;}
    @keyframes glow{0%,100%{box-shadow:0 0 5px rgba(102,126,234,.5);}50%{box-shadow:0 0 15px rgba(102,126,234,.8);}}
    .section-action{width:28px;height:28px;background:var(--glass-bg);border:1px solid var(--border-color);border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all var(--transition-base);color:var(--text-secondary);}
    .section-action:hover{background:var(--primary-gradient);border-color:transparent;color:#fff;transform:rotate(90deg);}

    .card{background:var(--glass-bg);border:1px solid var(--border-color);border-radius:18px;padding:24px;margin-bottom:18px;transition:all var(--transition-base);position:relative;overflow:hidden;}
    .card:hover{background:var(--glass-hover);border-color:var(--border-hover);box-shadow:var(--shadow-lg);transform:translateY(-2px);}

    .main-view{background:radial-gradient(ellipse at center,rgba(20,25,45,.6) 0%,rgba(5,7,20,.95) 100%);position:relative;overflow:hidden;}
    .main-view::before{content:'';position:absolute;inset:0;background-image:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(100,150,255,.03) 2px,rgba(100,150,255,.03) 4px);pointer-events:none;z-index:1;}
    #canvas-container{position:relative;z-index:2;width:100%;height:100%;}
    /* We keep a canvas for WebGL only (Three.js). */
    #renderCanvas{width:100%;height:100%;display:block;}

    .visualization-hud{position:absolute;inset:0;pointer-events:none;z-index:10;}
    .hud-element{position:absolute;background:linear-gradient(135deg,var(--panel-bg) 0%,rgba(25,30,50,.95) 100%);backdrop-filter:blur(20px);border:1px solid var(--border-color);border-radius:18px;padding:20px;pointer-events:auto;animation:fadeInScale .5s ease;box-shadow:var(--shadow-xl);}
    @keyframes fadeInScale{from{opacity:0;transform:scale(.9);}to{opacity:1;transform:scale(1);}}
    .metrics-panel{top:30px;left:30px;min-width:320px;}
    .tools-panel{top:30px;right:30px;display:flex;flex-direction:column;gap:12px;}
    .tool-btn{width:54px;height:54px;background:linear-gradient(135deg,var(--panel-bg) 0%,rgba(25,30,50,.95) 100%);backdrop-filter:blur(20px);border:1px solid var(--border-color);border-radius:16px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all var(--transition-base);font-size:22px;color:var(--text-secondary);position:relative;overflow:hidden;}
    .tool-btn:hover{border-color:transparent;transform:scale(1.1);box-shadow:var(--shadow-glow);color:#fff;}
    .tool-btn.active{background:var(--primary-gradient);color:#fff;border-color:transparent;}
    .view-controls{bottom:30px;left:30px;display:flex;gap:12px;}
    .view-btn{padding:14px 24px;background:var(--glass-bg);backdrop-filter:blur(20px);border:1px solid var(--border-color);border-radius:12px;color:var(--text-secondary);font-size:12px;font-weight:600;cursor:pointer;transition:all var(--transition-base);text-transform:uppercase;letter-spacing:.5px;font-family:var(--font-stack);}
    .view-btn:hover{background:var(--glass-hover);border-color:var(--border-hover);color:var(--text-primary);transform:translateY(-2px);box-shadow:var(--shadow-lg);}
    .view-btn.active{background:var(--primary-gradient);border-color:transparent;color:#fff;box-shadow:var(--shadow-glow);}
    .coordinates{bottom:30px;right:30px;font-size:11px;color:var(--text-tertiary);font-family:'SF Mono','Monaco','Inconsolata','Fira Code',monospace;background:var(--panel-bg);padding:12px 16px;border-radius:10px;border:1px solid var(--border-color);display:flex;gap:16px;}

    /* Right panel tabs and cards remain; only charts replaced with SVG. */
    .analysis-tabs{display:flex;gap:6px;margin-bottom:28px;background:var(--glass-bg);padding:6px;border-radius:14px;}
    .analysis-tab{flex:1;padding:14px;background:transparent;border:none;color:var(--text-secondary);cursor:pointer;font-size:13px;font-weight:600;border-radius:10px;transition:all var(--transition-base);font-family:var(--font-stack);text-align:center;}
    .analysis-tab:hover{background:var(--glass-hover);color:var(--text-primary);}
    .analysis-tab.active{background:var(--primary-gradient);color:#fff;box-shadow:var(--shadow-md);}
    .chart-card{background:var(--glass-bg);border:1px solid var(--border-color);border-radius:18px;padding:24px;margin-bottom:24px;transition:all var(--transition-base);}
    .chart-card:hover{background:var(--glass-hover);border-color:var(--border-hover);box-shadow:var(--shadow-lg);}
    .chart-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;}
    .chart-title{font-size:15px;font-weight:600;color:var(--text-primary);}
    .chart-actions{display:flex;gap:8px;}
    .chart-action{width:28px;height:28px;background:var(--glass-bg);border:1px solid var(--border-color);border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:14px;color:var(--text-secondary);transition:all var(--transition-base);}
    .chart-action:hover{background:var(--primary-gradient);border-color:transparent;color:#fff;transform:scale(1.1);}
    .chart-container{height:220px;background:linear-gradient(180deg,rgba(5,7,20,.5) 0%,rgba(5,7,20,.8) 100%);border-radius:14px;padding:0 0;position:relative;overflow:hidden;display:flex;align-items:stretch;}
    .chart-svg{width:100%;height:100%;}
    .chart-grid line{stroke:rgba(100,150,255,.1);stroke-width:1}

    .timeline{grid-column:1/-1;background:linear-gradient(135deg,var(--panel-bg) 0%,rgba(25,30,50,.98) 100%);backdrop-filter:blur(20px);border-top:1px solid var(--border-color);display:flex;align-items:center;padding:0 30px;gap:30px;position:relative;overflow:hidden;}
    .timeline::before{content:'';position:absolute;bottom:0;left:-100%;width:200%;height:2px;background:var(--primary-gradient);animation:scanline 4s linear infinite;}
    .playback-controls{display:flex;align-items:center;gap:16px;}
    .playback-btn{width:56px;height:56px;background:var(--primary-gradient);border:none;border-radius:50%;color:#fff;font-size:24px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all var(--transition-base);box-shadow:var(--shadow-glow);position:relative;}
    .secondary-btn{width:40px;height:40px;background:var(--glass-bg);border:1px solid var(--border-color);border-radius:50%;color:var(--text-secondary);font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all var(--transition-base);font-family:var(--font-stack);}
    .timeline-container{flex:1;display:flex;flex-direction:column;gap:12px;}
    .timeline-info{display:flex;justify-content:space-between;align-items:center;}
    .timeline-track{position:relative;height:10px;background:linear-gradient(90deg,rgba(100,150,255,.1) 0%,rgba(100,150,255,.15) 100%);border-radius:5px;cursor:pointer;overflow:visible;}
    .timeline-buffer{position:absolute;top:0;left:0;height:100%;background:linear-gradient(90deg,rgba(100,150,255,.2) 0%,rgba(100,150,255,.3) 100%);border-radius:5px;width:60%;}
    .timeline-progress{position:absolute;top:0;left:0;height:100%;background:var(--primary-gradient);border-radius:5px;width:35%;box-shadow:0 0 20px rgba(102,126,234,.5);position:relative;}
    .timeline-handle{position:absolute;top:50%;left:35%;transform:translate(-50%,-50%);width:24px;height:24px;background:#fff;border:3px solid var(--accent-blue);border-radius:50%;cursor:grab;box-shadow:var(--shadow-lg);transition:all var(--transition-base);z-index:2;}
    .speed-control{display:flex;align-items:center;gap:12px;padding:10px 18px;background:var(--glass-bg);border:1px solid var(--border-color);border-radius:12px;}

    /* Notifications & modal kept as-is (fixed bugs in JS). */
    .notifications{position:fixed;top:100px;right:30px;z-index:60000;display:flex;flex-direction:column;gap:12px;}
    .notification{background:var(--panel-bg);backdrop-filter:blur(20px);border:1px solid var(--border-color);border-radius:14px;padding:16px 20px;display:flex;align-items:center;gap:16px;min-width:320px;animation:slideInRight .3s ease;box-shadow:var(--shadow-xl);}
    .notification-icon{width:36px;height:36px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:18px;flex-shrink:0;}
    .notification.success .notification-icon{background:rgba(0,214,143,.2);color:var(--success);}
    .notification.warning .notification-icon{background:rgba(255,170,0,.2);color:var(--warning);}
    .notification.error .notification-icon{background:rgba(255,61,113,.2);color:var(--danger);}
    .notification-title{font-size:14px;font-weight:600;color:var(--text-primary);margin-bottom:4px;}
    .notification-message{font-size:12px;color:var(--text-secondary);}
    .notification-close{width:24px;height:24px;display:flex;align-items:center;justify-content:center;cursor:pointer;color:var(--text-tertiary);transition:all var(--transition-base);}
    .notification-close:hover{color:var(--danger);transform:scale(1.2) rotate(90deg);}
    @keyframes slideInRight{from{transform:translateX(100px);opacity:0;}to{transform:translateX(0);opacity:1;}}

    .loading-screen{position:fixed;inset:0;background:var(--dark-bg);
      background-image:radial-gradient(ellipse at center,rgba(102,126,234,.2) 0%,transparent 70%);
      display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100000;animation:fadeOut .5s ease 3s forwards;pointer-events:none;}
    @keyframes fadeOut{to{opacity:0;visibility:hidden;}}
    .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);backdrop-filter:blur(10px);display:none;align-items:center;justify-content:center;z-index:50000;}
    .modal-overlay.active{display:flex;animation:fadeIn .3s ease;}
    @keyframes fadeIn{from{opacity:0;}to{opacity:1;}}
    .modal{background:var(--panel-bg);border:1px solid var(--border-color);border-radius:24px;padding:24px 28px;max-width:720px;width:92vw;max-height:80vh;overflow:auto;box-shadow:var(--shadow-xl);}

    /* SVG badge for AI voice state */
    .mic-indicator{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid var(--border-color);border-radius:12px;background:var(--glass-bg);font-size:12px;color:var(--text-secondary);}
    .mic-dot{width:8px;height:8px;border-radius:50%;background:var(--danger);box-shadow:0 0 10px var(--danger);}
    .mic-on .mic-dot{background:var(--success);box-shadow:0 0 10px var(--success);}
    .ai-help{font-size:12px;color:var(--text-tertiary);margin-top:8px;line-height:1.5}

    @media (max-width:1600px){.app-container{grid-template-columns:350px 1fr 400px;}}
    @media (max-width:1400px){.app-container{grid-template-columns:320px 1fr 360px;}.logo-title{font-size:20px}.nav-btn{padding:10px 18px;font-size:12px}}
    @media print{body{background:#fff;color:#000}.header,.timeline,.tools-panel{display:none}.main-view{background:#fff}}
  </style>
</head>
<body>
  <!-- Background Particles -->
  <div class="bg-particles" id="particles"></div>

  <!-- Loading Screen -->
  <div class="loading-screen" id="loadingScreen">
    <div class="loading-content">
      <div class="heart-loader">
        <svg width="120" height="120" viewBox="0 0 120 120">
          <defs>
            <linearGradient id="heartGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
              <stop offset="50%" style="stop-color:#f093fb;stop-opacity:1" />
              <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
            </linearGradient>
          </defs>
          <path class="heart-path" d="M60,30 C50,15 30,15 30,35 C30,55 60,85 60,85 C60,85 90,55 90,35 C90,15 70,15 60,30 Z"
                fill="none" stroke="url(#heartGradient)" stroke-width="3">
            <animate attributeName="stroke-dasharray" values="0,300;300,0;0,300" dur="2s" repeatCount="indefinite"/>
          </path>
        </svg>
      </div>
      <div class="loading-progress"><div class="loading-bar" style="height:6px;background:var(--primary-gradient);width:0;animation:loadProgress 3s ease-out forwards;"></div></div>
      <div class="loading-text" style="letter-spacing:3px;text-transform:uppercase;animation:pulse 1.5s ease-in-out infinite;">Initializing Digital Twin</div>
    </div>
  </div>

  <!-- Main Application -->
  <div class="app-container">
    <!-- Header -->
    <header class="header">
      <div class="logo-section">
        <div class="logo" id="tour-start"><div class="logo-icon">❤️</div></div>
        <div class="logo-text">
          <div class="logo-title">MitralViz Pro™</div>
          <div class="logo-subtitle">Digital Twin System v4.0</div>
        </div>
      </div>

      <nav class="header-nav">
        <button class="nav-btn" id="btnImport"><span>Import DICOM</span></button>
        <button class="nav-btn" id="btnExport"><span>Export</span></button>
        <button class="nav-btn active" id="btnSim"><span>Simulation</span></button>
        <button class="nav-btn" id="btnXR"><span>AR/VR</span></button>
        <button class="nav-btn" id="btnSettings"><span>Settings</span></button>
        <button class="nav-btn" id="btnVoice"><span>🎙️ Voice</span></button>
      </nav>

      <div class="header-status">
        <div id="micIndicator" class="mic-indicator" title="AI Voice Assistant">
          <span class="mic-dot"></span><span>Assistant</span>
        </div>
        <div class="status-indicator"><div class="status-dot"></div><span class="status-text" id="statusText">System Ready</span></div>
      </div>
    </header>

    <!-- Left Panel -->
    <aside class="left-panel">
      <!-- Patient Info -->
      <section class="section">
        <div class="section-header">
          <h3 class="section-title">Patient Information</h3>
          <div class="section-action" title="Edit in Settings">⚙️</div>
        </div>
        <div class="card">
          <div class="patient-header">
            <div class="patient-avatar" id="patientAvatar">JD</div>
            <div class="patient-info">
              <div class="patient-name" id="patientName">Jane Doe</div>
              <div class="patient-id" id="patientId">ID: MV-2024-0847</div>
              <div class="patient-tags">
                <span class="tag" id="patientSex">Female</span>
                <span class="tag" id="patientAge">67y</span>
                <span class="tag critical" id="patientFlag">MR</span>
              </div>
            </div>
          </div>
          <div class="info-grid">
            <div class="info-item"><span class="info-label">Diagnosis</span><span class="info-value highlight" id="patientDx">Moderate MR</span></div>
            <div class="info-item"><span class="info-label">NYHA Class</span><span class="info-value" id="patientNYHA">II</span></div>
            <div class="info-item"><span class="info-label">BMI</span><span class="info-value" id="patientBMI">24.3</span></div>
            <div class="info-item"><span class="info-label">BSA</span><span class="info-value" id="patientBSA">1.76 m²</span></div>
            <div class="info-item"><span class="info-label">EF</span><span class="info-value" id="patientEF">58%</span></div>
            <div class="info-item"><span class="info-label">LA Volume</span><span class="info-value" id="patientLA">92 mL</span></div>
          </div>
        </div>
      </section>

      <!-- Visualization Controls -->
      <section class="section">
        <div class="section-header">
          <h3 class="section-title">Visualization</h3>
          <div class="section-action">👁️</div>
        </div>
        <div class="card">
          <!-- Opacity slider -->
          <div class="control-group" data-slider="opacity">
            <div class="control-label"><span>Tissue Opacity</span><span class="control-value" id="lblOpacity">85%</span></div>
            <div class="slider-container">
              <div class="slider-track"><div class="slider-fill" id="fillOpacity" style="width:85%"></div></div>
              <div class="slider-handle" id="handleOpacity" style="left:85%"></div>
            </div>
            <div class="slider-marks"><span class="slider-mark">0%</span><span class="slider-mark">50%</span><span class="slider-mark">100%</span></div>
          </div>

          <!-- Slice slider -->
          <div class="control-group" data-slider="slice">
            <div class="control-label"><span>Slice Position</span><span class="control-value" id="lblSlice">Mid</span></div>
            <div class="slider-container">
              <div class="slider-track"><div class="slider-fill" id="fillSlice" style="width:50%"></div></div>
              <div class="slider-handle" id="handleSlice" style="left:50%"></div>
            </div>
            <div class="slider-marks"><span class="slider-mark">Apex</span><span class="slider-mark">Mid</span><span class="slider-mark">Base</span></div>
          </div>

          <!-- Layers -->
          <div class="control-group">
            <div class="control-label"><span>Layers</span></div>
            <div class="toggle-grid" id="layersGrid">
              <button class="toggle-btn active" data-layer="tissue"><span>Tissue</span></button>
              <button class="toggle-btn active" data-layer="flow"><span>Blood Flow</span></button>
              <button class="toggle-btn" data-layer="calcium"><span>Calcium</span></button>
              <button class="toggle-btn active" data-layer="annulus"><span>Annulus</span></button>
              <button class="toggle-btn" data-layer="chordae"><span>Chordae</span></button>
              <button class="toggle-btn" data-layer="papillary"><span>Papillary</span></button>
            </div>
          </div>
        </div>
      </section>

      <!-- Scenarios -->
      <section class="section">
        <div class="section-header"><h3 class="section-title">Scenarios</h3><div class="section-action">🔬</div></div>
        <div class="card">
          <div class="simulation-grid" id="scenarioGrid">
            <div class="sim-card active" data-scenario="normal"><div class="sim-icon">❤️</div><span class="sim-label">Normal</span></div>
            <div class="sim-card" data-scenario="mild-mr"><div class="sim-icon">💧</div><span class="sim-label">Mild MR</span></div>
            <div class="sim-card" data-scenario="moderate-mr"><div class="sim-icon">💦</div><span class="sim-label">Mod MR</span></div>
            <div class="sim-card" data-scenario="severe-mr"><div class="sim-icon">🌊</div><span class="sim-label">Severe</span></div>
            <div class="sim-card" data-scenario="prolapse"><div class="sim-icon">📈</div><span class="sim-label">Prolapse</span></div>
            <div class="sim-card" data-scenario="stenosis"><div class="sim-icon">🚫</div><span class="sim-label">Stenosis</span></div>
            <div class="sim-card" data-scenario="flail"><div class="sim-icon">🌪️</div><span class="sim-label">Flail</span></div>
            <div class="sim-card" data-scenario="repair"><div class="sim-icon">🔧</div><span class="sim-label">Repair</span></div>
            <div class="sim-card" data-scenario="prosthetic"><div class="sim-icon">⚙️</div><span class="sim-label">Prosthetic</span></div>
          </div>
        </div>
      </section>

      <!-- Hemodynamics -->
      <section class="section">
        <div class="section-header"><h3 class="section-title">Hemodynamics</h3><div class="section-action">💉</div></div>
        <div class="card">
          <div class="control-group" data-slider="hr">
            <div class="control-label"><span>Heart Rate</span><span class="control-value" id="lblHR">72 bpm</span></div>
            <div class="slider-container"><div class="slider-track"><div class="slider-fill" id="fillHR" style="width:40%"></div></div><div class="slider-handle" id="handleHR" style="left:40%"></div></div>
          </div>
          <div class="control-group" data-slider="sbp">
            <div class="control-label"><span>Systolic BP</span><span class="control-value" id="lblSBP">120 mmHg</span></div>
            <div class="slider-container"><div class="slider-track"><div class="slider-fill" id="fillSBP" style="width:50%"></div></div><div class="slider-handle" id="handleSBP" style="left:50%"></div></div>
          </div>
        </div>
      </section>
    </aside>

    <!-- Main 3D View -->
    <main class="main-view">
      <div id="canvas-container"><canvas id="renderCanvas"></canvas></div>

      <div class="visualization-hud">
        <!-- Metrics Panel -->
        <div class="hud-element metrics-panel">
          <h4 class="metrics-header">Real-time Metrics</h4>
          <div class="metrics-grid">
            <div class="metric-row">
              <div class="metric-label"><span class="metric-indicator warning" id="indMR"></span><span>MR Volume</span></div>
              <div class="metric-value"><span id="mrVolume">28.4</span><span class="metric-unit">mL/beat</span></div>
            </div>
            <div class="metric-row">
              <div class="metric-label"><span class="metric-indicator warning" id="indEROA"></span><span>EROA</span></div>
              <div class="metric-value"><span id="eroa">0.32</span><span class="metric-unit">cm²</span></div>
            </div>
            <div class="metric-row">
              <div class="metric-label"><span class="metric-indicator" id="indPV"></span><span>Peak Velocity</span></div>
              <div class="metric-value"><span id="peakVel">4.8</span><span class="metric-unit">m/s</span></div>
            </div>
            <div class="metric-row">
              <div class="metric-label"><span class="metric-indicator" id="indMG"></span><span>Mean Gradient</span></div>
              <div class="metric-value"><span id="meanGrad">8.5</span><span class="metric-unit">mmHg</span></div>
            </div>
          </div>
        </div>

        <!-- Tools -->
        <div class="hud-element tools-panel">
          <button class="tool-btn" id="btnMeasure" title="Measurement Tool (M)"><span>📏</span></button>
          <button class="tool-btn" id="btnAnnotate" title="Annotation Tool (A)"><span>✏️</span></button>
          <button class="tool-btn" id="btnShot" title="Screenshot (S)"><span>📸</span></button>
          <button class="tool-btn" id="btnRecord" title="Start/Stop Recording (R)"><span>🎥</span></button>
          <button class="tool-btn" id="btnFull" title="Fullscreen (F)"><span>⛶</span></button>
        </div>

        <!-- View Controls -->
        <div class="hud-element view-controls">
          <button class="view-btn active" data-view="3d">3D View</button>
          <button class="view-btn" data-view="4ch">4-Chamber</button>
          <button class="view-btn" data-view="lax">Long Axis</button>
          <button class="view-btn" data-view="sax">Short Axis</button>
        </div>

        <!-- Coordinates -->
        <div class="hud-element coordinates">
          <div class="coord-item"><span class="coord-label">X:</span><span class="coord-value" id="coordX">0.00</span></div>
          <div class="coord-item"><span class="coord-label">Y:</span><span class="coord-value" id="coordY">0.00</span></div>
          <div class="coord-item"><span class="coord-label">Z:</span><span class="coord-value" id="coordZ">0.00</span></div>
          <div class="coord-item"><span class="coord-label">FPS:</span><span class="coord-value" id="fps">60</span></div>
        </div>
      </div>
    </main>

    <!-- Right Panel -->
    <aside class="right-panel">
      <div class="analysis-tabs">
        <button class="analysis-tab active" data-tab="analysis">Analysis</button>
        <button class="analysis-tab" data-tab="measurements">Measurements</button>
        <button class="analysis-tab" data-tab="ai">AI Insights</button>
        <button class="analysis-tab" data-tab="reports">Reports</button>
      </div>

      <div id="analysisContent">
        <!-- Pressure Chart (SVG) -->
        <div class="chart-card">
          <div class="chart-header">
            <h4 class="chart-title">Pressure Waveforms</h4>
            <div class="chart-actions"><button class="chart-action" title="Options">⚙️</button><button class="chart-action" title="Export SVG" id="btnExportPressure">📊</button></div>
          </div>
          <div class="chart-container">
            <svg id="pressureSVG" class="chart-svg" viewBox="0 0 800 220" preserveAspectRatio="none">
              <g class="chart-grid"></g>
              <path id="lvpPath" fill="none" stroke="rgba(102,126,234,0.9)" stroke-width="2"/>
              <path id="lapPath" fill="none" stroke="rgba(240,147,251,0.9)" stroke-width="2"/>
            </svg>
          </div>
        </div>

        <!-- Flow Chart (SVG) -->
        <div class="chart-card">
          <div class="chart-header">
            <h4 class="chart-title">Flow Velocity</h4>
            <div class="chart-actions"><button class="chart-action" title="Options">⚙️</button><button class="chart-action" title="Export SVG" id="btnExportFlow">📊</button></div>
          </div>
          <div class="chart-container">
            <svg id="flowSVG" class="chart-svg" viewBox="0 0 800 220" preserveAspectRatio="none">
              <g class="chart-grid"></g>
              <path id="tmfPath" fill="none" stroke="rgba(0,212,143,0.9)" stroke-width="2"/>
              <path id="regPath" fill="none" stroke="rgba(255,100,100,0.7)" stroke-width="2"/>
            </svg>
          </div>
        </div>

        <!-- Morphology Data (kept) -->
        <div class="chart-card">
          <div class="chart-header"><h4 class="chart-title">Valve Morphology</h4></div>
          <div class="data-table">
            <div class="data-table-header">
              <span class="data-table-cell">Parameter</span><span class="data-table-cell">Value</span><span class="data-table-cell">Normal</span>
            </div>
            <div class="data-table-row"><span class="data-cell">Annulus</span><span class="data-cell value" id="mAnnulus">32 mm</span><span class="data-cell normal">28–30</span></div>
            <div class="data-table-row"><span class="data-cell">Anterior</span><span class="data-cell value" id="mAnterior">24 mm</span><span class="data-cell normal">22–26</span></div>
            <div class="data-table-row"><span class="data-cell">Posterior</span><span class="data-cell value" id="mPosterior">14 mm</span><span class="data-cell normal">12–16</span></div>
            <div class="data-table-row"><span class="data-cell">Coaptation</span><span class="data-cell value" id="mCoaptation">7.2 mm</span><span class="data-cell normal">8–10</span></div>
          </div>
        </div>

        <!-- AI Insights (kept, with safety notice) -->
        <div class="ai-card">
          <div class="ai-header"><div class="ai-icon">🤖</div><h4 class="ai-title">AI Analysis (Educational)</h4><span class="ai-confidence" id="aiConf">95% Confidence</span></div>
          <div class="ai-content" id="aiText">
            AI analysis detects moderate mitral regurgitation with posterior leaflet prolapse (P2). EROA and regurgitant volume suggest moderate severity requiring follow‑up.
          </div>
          <div class="ai-recommendations" id="aiRecs">
            <div class="recommendation"><div class="recommendation-icon">✓</div><span class="recommendation-text">Trend echocardiographic metrics at regular intervals.</span></div>
            <div class="recommendation"><div class="recommendation-icon">✓</div><span class="recommendation-text">Consider multidisciplinary review if symptoms progress.</span></div>
            <div class="recommendation"><div class="recommendation-icon">!</div><span class="recommendation-text">This simulation is not a medical device. Do not use for diagnosis.</span></div>
          </div>
        </div>
      </div>
    </aside>

    <!-- Timeline -->
    <div class="timeline">
      <div class="playback-controls">
        <button class="secondary-btn" id="btnPrev" title="Previous Frame (←)">⏮</button>
        <button class="playback-btn" id="playBtn" title="Play/Pause (Space)">▶</button>
        <button class="secondary-btn" id="btnNext" title="Next Frame (→)">⏭</button>
      </div>

      <div class="timeline-container">
        <div class="timeline-info">
          <div class="timeline-time"><span id="currentTime">0.350</span> / <span id="totalTime">1.000</span> sec</div>
          <div class="timeline-phases">
            <div class="phase" id="diastole"><div class="phase-dot"></div><span class="phase-name">Diastole</span></div>
            <div class="phase active" id="systole"><div class="phase-dot"></div><span class="phase-name">Systole</span></div>
            <div class="phase" id="isovolumetric"><div class="phase-dot"></div><span class="phase-name">Isovolumetric</span></div>
          </div>
        </div>
        <div class="timeline-track" id="timelineTrack">
          <div class="timeline-buffer"></div>
          <div class="timeline-progress" id="timelineProgress"></div>
          <div class="timeline-handle" id="timelineHandle"></div>
        </div>
      </div>

      <div class="speed-control">
        <span class="speed-label">Speed:</span>
        <button class="secondary-btn" id="btnSlow">−</button>
        <span class="speed-value" id="speedText">1×</span>
        <button class="secondary-btn" id="btnFast">+</button>
      </div>
    </div>
  </div>

  <!-- Notifications -->
  <div class="notifications" id="notifications"></div>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <h2 style="margin-bottom:10px;">Settings</h2>
      <p style="color:var(--text-tertiary);margin-bottom:16px;">Adjust advanced rendering and analysis options. These persist in localStorage.</p>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px;">
        <label><input type="checkbox" id="chkBloom" checked/> Bloom</label>
        <label><input type="checkbox" id="chkSSAO" checked/> Screen-Space Ambient Occlusion</label>
        <label><input type="checkbox" id="chkFXAA" checked/> FXAA Antialiasing</label>
        <label><input type="checkbox" id="chkAnimateCoaptation" checked/> Animate Coaptation</label>
        <label><input type="checkbox" id="chkBloodFlow" checked/> Blood Flow Particles</label>
        <label><input type="checkbox" id="chkRimLights" checked/> Rim Lights</label>
      </div>
      <div style="display:flex;gap:12px;align-items:center;margin-bottom:16px;">
        <label style="min-width:120px;">Bloom Strength</label>
        <input type="range" id="rngBloom" min="0" max="3" step="0.05" value="0.8" style="flex:1;"/>
        <span id="lblBloom">0.80</span>
      </div>
      <div class="ai-help">Note: This app is for education & research only.</div>
      <div style="margin-top:16px;display:flex;justify-content:flex-end;gap:8px;">
        <button class="nav-btn" id="btnResetSettings"><span>Reset</span></button>
        <button class="nav-btn active" onclick="document.getElementById('settingsModal').classList.remove('active')"><span>Close</span></button>
      </div>
    </div>
  </div>

  <!-- ========== Scripts (CDN, no build step) ============================ -->
  <!-- Three.js core -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Controls and helpers -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/renderers/CSS2DRenderer.js"></script>
  <!-- Post-processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/shaders/FXAAShader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/SSAOPass.js"></script>
  <!-- WebXR buttons (optional) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/webxr/ARButton.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/webxr/VRButton.js"></script>
  <!-- DICOM parser (dcmjs) -->
  <script src="https://cdn.jsdelivr.net/npm/dcmjs@0.29.7/build/dcmjs.min.js"></script>

  <!-- =================== APP CODE ======================================= -->
  <script>
    // =====================================================
    // ADVANCED MITRAL VALVE DIGITAL TWIN (EDU/RESEARCH)
    // =====================================================
    // Notes:
    // - All original features maintained or completed.
    // - Full fixes for backticks, notifications, shaders, event wiring.
    // - SVG charts, not canvas (except WebGL canvas for 3D).
    // - Voice assistant powered by Web Speech APIs.
    // - MediaRecorder for video capture.
    // - AR/VR fallback with WebXR if available.
    // - DICOM import via dcmjs (metadata).
    // -----------------------------------------------------

    class MitralValveApp {
      constructor() {
        // Core
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.css2d = null;
        this.composer = null;
        this.controls = null;
        this.clock = new THREE.Clock();
        this.animationId = 0;

        // Postprocessing passes
        this.renderPass = null;
        this.fxaaPass = null;
        this.bloomPass = null;
        this.ssaoPass = null;

        // Simulation state
        this.isPlaying = true;
        this.currentTime = 0;              // seconds
        this.cardiacCycle = 0.833;         // 72 bpm ≈ 0.833 s/cycle
        this.speed = 1;
        this.draggingTimeline = false;

        // Model groups
        this.valveGroup = new THREE.Group();
        this.anteriorLeaflet = null;
        this.posteriorLeaflet = null;
        this.annulusMesh = null;
        this.chordaeGroup = new THREE.Group();
        this.papGroup = new THREE.Group();
        this.calciumGroup = new THREE.Group();
        this.bloodParticles = null;
        this.clippingPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0); // apex→base slice

        // Materials cache
        this.leafletMats = [];
        this.baseLeafletOpacity = 0.85;

        // Measurement & annotation
        this.isMeasuring = false;
        this.isAnnotating = false;
        this.raycaster = new THREE.Raycaster();
        this.pointer = new THREE.Vector2();
        this.measurePoints = [];
        this.measureGroup = new THREE.Group();
        this.annotationGroup = new THREE.Group();
        this.labelRendererReady = false;

        // Hemodynamics (baseline)
        this.hemodynamics = {
          heartRate: 72,
          systolicPressure: 120,
          diastolicPressure: 80,
          leftAtrialPressure: 10,
          strokeVolume: 70,
          regurgitantFraction: 0.3
        };

        // Recording
        this.recorder = null;
        this.recordChunks = [];
        this.isRecording = false;

        // Voice
        this.voiceActive = false;
        this.recognition = null;

        // Init
        if (!this.checkWebGLSupport()) {
          this.showError("WebGL is not supported in your browser.");
          return;
        }
        this.init();
      }

      checkWebGLSupport() {
        try {
          const canvas = document.createElement('canvas');
          return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
        } catch (e) { return false; }
      }

      init() {
        // Renderer
        const container = document.getElementById('canvas-container');
        this.renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById('renderCanvas'),
          antialias: true, alpha: true, powerPreference: 'high-performance'
        });
        this.renderer.setSize(container.clientWidth, container.clientHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.2;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.localClippingEnabled = true;

        // CSS2D for crisp labels
        this.css2d = new THREE.CSS2DRenderer();
        this.css2d.setSize(container.clientWidth, container.clientHeight);
        this.css2d.domElement.style.position = 'absolute';
        this.css2d.domElement.style.top = '0';
        this.css2d.domElement.style.pointerEvents = 'none';
        container.appendChild(this.css2d.domElement);
        this.labelRendererReady = true;

        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x050510);
        this.scene.fog = new THREE.FogExp2(0x050510, 0.02);

        // Env map (soft)
        const pmrem = new THREE.PMREMGenerator(this.renderer);
        const envRT = pmrem.fromEquirectangular(this.generateGradientTexture());
        this.scene.environment = envRT.texture;

        // Camera
        this.camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
        this.camera.position.set(0, 15, 40);
        this.camera.lookAt(0, 0, 0);

        // Controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 18;
        this.controls.maxDistance = 100;
        this.controls.enablePan = true;

        // Lighting
        this.setupLighting();

        // Anatomical model
        this.createRealisticValve();
        this.createBloodFlowSystem();

        // Aux groups
        this.scene.add(this.measureGroup);
        this.scene.add(this.annotationGroup);

        // Post-processing
        this.setupPostProcessing();

        // UI & events
        this.setupEventListeners();
        this.createParticlesBackground();
        this.setupSliders();
        this.setupLayerToggles();
        this.setupScenarios();
        this.setupViews();
        this.setupSVGCharts();

        // Hide loading
        setTimeout(() => { const ls = document.getElementById('loadingScreen'); if (ls) ls.style.display = 'none'; }, 3000);

        // Render loop
        this.animate();
      }

      // === Rendering helpers ===
      generateGradientTexture() {
        // Small equirect gradient as DataTexture (avoids external files)
        const w = 64, h = 32;
        const size = w * h * 3;
        const data = new Uint8Array(size);
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const i = (y * w + x) * 3;
            const t = y / (h - 1);
            const r = Math.round(10 + 30 * (1 - t));
            const g = Math.round(15 + 45 * (1 - t));
            const b = Math.round(40 + 80 * t);
            data[i] = r; data[i + 1] = g; data[i + 2] = b;
          }
        }
        const tex = new THREE.DataTexture(data, w, h, THREE.RGBFormat);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.needsUpdate = true;
        return tex;
      }

      setupLighting() {
        this.scene.add(new THREE.AmbientLight(0x404060, 0.4));
        const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
        keyLight.position.set(10, 20, 10);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.set(2048, 2048);
        keyLight.shadow.camera.near = 0.5;
        keyLight.shadow.camera.far = 60;
        keyLight.shadow.camera.left = -25;
        keyLight.shadow.camera.right = 25;
        keyLight.shadow.camera.top = 25;
        keyLight.shadow.camera.bottom = -25;
        this.scene.add(keyLight);

        // Fill and rim lights (toggleable)
        this.fillLight = new THREE.DirectionalLight(0x8899ff, 0.35);
        this.fillLight.position.set(-10, 10, -5);
        this.scene.add(this.fillLight);

        this.rim1 = new THREE.PointLight(0xff6b9d, 0.6, 40); this.rim1.position.set(-10, 5, 10); this.scene.add(this.rim1);
        this.rim2 = new THREE.PointLight(0x667eea, 0.6, 40); this.rim2.position.set(10, 5, -10); this.scene.add(this.rim2);

        // Spotlight for central emphasis
        const spot = new THREE.SpotLight(0xffffff, 0.35);
        spot.position.set(0, 30, 0); spot.angle = Math.PI / 6; spot.penumbra = 0.3; spot.decay = 2; spot.distance = 100; spot.castShadow = true;
        this.scene.add(spot);
      }

      // === Procedural tissue textures ===
      createTissueNormalTexture(size = 256) {
        // Simple fractal noise to approximate fibrosa microstructure (tangent-space normal map)
        const data = new Uint8Array(size * size * 3);
        const noise = (x, y) => {
          let v = 0, amp = 1, freq = 1;
          for (let i = 0; i < 4; i++) {
            const nx = Math.sin((x * freq) * 0.1) * Math.cos((y * freq) * 0.13);
            const ny = Math.cos((x * freq) * 0.07) * Math.sin((y * freq) * 0.09);
            v += (nx + ny) * 0.5 * amp; amp *= 0.5; freq *= 2.0;
          }
          return v;
        };
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const i = (y * size + x) * 3;
            const n = noise(x, y);
            // Build a normal vector mapped to [0,255]
            const nx = 128 + 80 * n;
            const ny = 128 + 80 * (-n);
            const nz = 255;
            data[i] = Math.max(0, Math.min(255, nx));
            data[i + 1] = Math.max(0, Math.min(255, ny));
            data[i + 2] = nz;
          }
        }
        const tex = new THREE.DataTexture(data, size, size, THREE.RGBFormat);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.needsUpdate = true;
        return tex;
      }

      createThicknessTexture(size = 256) {
        const data = new Uint8Array(size * size);
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const u = x / (size - 1), v = y / (size - 1);
            const ring = Math.sin(u * Math.PI) * Math.cos(v * Math.PI);
            const t = 150 + 80 * ring; // [0..255]
            data[y * size + x] = Math.max(0, Math.min(255, t));
          }
        }
        const tex = new THREE.DataTexture(data, size, size, THREE.LuminanceFormat);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.needsUpdate = true;
        return tex;
      }

      // === Anatomy ===
      createRealisticValve() {
        const normalTex = this.createTissueNormalTexture(256);
        const thickTex  = this.createThicknessTexture(256);

        // ANNULUS (D-shaped)
        const annulusPts = [];
        for (let i = 0; i <= 128; i++) {
          const t = (i / 128) * Math.PI * 2;
          const r = 8 + 2 * Math.cos(2 * t);
          const x = r * Math.cos(t);
          const z = r * Math.sin(t) * 0.8;
          annulusPts.push(new THREE.Vector3(x, 0, z));
        }
        const annCurve = new THREE.CatmullRomCurve3(annulusPts, true);
        const annGeom = new THREE.TubeGeometry(annCurve, 128, 0.5, 24, true);
        const annMat = new THREE.MeshPhysicalMaterial({
          color: 0x9155cc, metalness: 0.1, roughness: 0.35, clearcoat: 0.3, clearcoatRoughness: 0.2,
          envMapIntensity: 0.6, transparent: true, opacity: 0.95
        });
        this.annulusMesh = new THREE.Mesh(annGeom, annMat);
        this.annulusMesh.castShadow = this.annulusMesh.receiveShadow = true;
        this.valveGroup.add(this.annulusMesh);

        // LEAFLETS (procedural parametric)
        this.anteriorLeaflet = this.createLeaflet(true, normalTex, thickTex);
        this.posteriorLeaflet = this.createLeaflet(false, normalTex, thickTex);
        this.valveGroup.add(this.anteriorLeaflet);
        this.valveGroup.add(this.posteriorLeaflet);

        // CHORDAE & PAPILLARY
        this.createPapillaryMuscles();
        this.createChordaeTendineae();

        // CALCIFICATION dots (toggleable)
        this.createCalcium();

        // Positioning, clipping
        this.valveGroup.traverse(obj => { obj.castShadow = true; obj.receiveShadow = true; obj.material && (obj.material.clippingPlanes = [this.clippingPlane]); });
        this.scene.add(this.valveGroup);
      }

      createLeaflet(isAnterior, normalTex, thickTex) {
        const g = new THREE.BufferGeometry();
        const segU = 40, segV = 40;
        const positions = [];
        const normals = [];
        const uvs = [];
        const indices = [];

        for (let v = 0; v <= segV; v++) {
          const vv = v / segV;
          for (let u = 0; u <= segU; u++) {
            const uu = u / segU;
            const theta = uu * Math.PI;
            const phi = vv * Math.PI * 0.55;

            let R = isAnterior ? (8 + 2.2 * Math.sin(phi)) : (6 + 1.6 * Math.sin(phi));
            let x = R * Math.cos(theta) * (1 - vv * (isAnterior ? 0.28 : 0.4)) * (isAnterior ? 1 : -1);
            let y = -vv * (isAnterior ? 6.5 : 4.5);
            let z = R * Math.sin(theta) * (1 - vv * (isAnterior ? 0.28 : 0.4)) * 0.72 * (isAnterior ? 1 : -1);

            // billowing & scallops
            if (isAnterior) {
              y += Math.sin(theta * 3.2) * Math.cos(phi * 1.8) * 0.45;
            } else {
              const scallop = Math.sin(theta * 3.0) * 0.35; // P1/P2/P3
              y += scallop * vv;
            }

            positions.push(x, y, z);
            normals.push(0, 1, 0);
            uvs.push(uu, vv);
          }
        }
        for (let v = 0; v < segV; v++) {
          for (let u = 0; u < segU; u++) {
            const a = u + (segU + 1) * v;
            const b = u + (segU + 1) * (v + 1);
            const c = (u + 1) + (segU + 1) * (v + 1);
            const d = (u + 1) + (segU + 1) * v;
            indices.push(a, b, d, b, c, d);
          }
        }
        g.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        g.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        g.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        g.setIndex(indices);
        g.computeVertexNormals();

        const mat = new THREE.MeshPhysicalMaterial({
          color: isAnterior ? 0xffc3c9 : 0xff8a95,
          metalness: 0.0, roughness: 0.62, clearcoat: 0.25, clearcoatRoughness: 0.35,
          normalMap: normalTex, normalScale: new THREE.Vector2(0.35, 0.35),
          transmission: 0.18, thickness: 0.9, thicknessMap: thickTex, ior: 1.35,
          envMapIntensity: 0.4, side: THREE.DoubleSide, transparent: true, opacity: this.baseLeafletOpacity
        });
        const leafletMesh = new THREE.Mesh(g, mat);
        const leafletGroup = new THREE.Group();
        leafletGroup.add(leafletMesh);

        // free edge highlight
        const edgeGeo = new THREE.EdgesGeometry(g, 30);
        const edgeMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.16 });
        leafletGroup.add(new THREE.LineSegments(edgeGeo, edgeMat));

        this.leafletMats.push(mat);
        return leafletGroup;
      }

      createPapillaryMuscles() {
        const mat = new THREE.MeshPhysicalMaterial({ color: 0xcc4466, metalness: 0, roughness: 0.85, clearcoat: 0.1, transparent: true, opacity: 0.95 });
        const geo1 = new THREE.CylinderGeometry(1.5, 2.7, 8.5, 20);
        const antero = new THREE.Mesh(geo1, mat);
        antero.position.set(-4, -18, 2); antero.rotation.z = 0.22;
        this.papGroup.add(antero);

        const geo2 = new THREE.CylinderGeometry(1.5, 2.7, 8.5, 20);
        const postero = new THREE.Mesh(geo2, mat);
        postero.position.set(4, -18, -2); postero.rotation.z = -0.22;
        this.papGroup.add(postero);

        this.valveGroup.add(this.papGroup);
      }

      createChordaeTendineae() {
        this.chordaeGroup.clear();
        const mat = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0, roughness: 0.95, transparent: true, opacity: 0.75, transmission: 0.25 });

        const primaryCount = 14;
        for (let i = 0; i < primaryCount; i++) {
          const angle = (i / primaryCount) * Math.PI * 2;
          const sx = Math.cos(angle) * 6, sz = Math.sin(angle) * 4, sy = -4;
          const ex = Math.cos(angle) * 3, ez = Math.sin(angle) * 2, ey = -14;

          const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(sx, sy, sz),
            new THREE.Vector3((sx + ex) / 2, (sy + ey) / 2 - 1.2, (sz + ez) / 2),
            new THREE.Vector3(ex, ey, ez)
          ]);
          const geom = new THREE.TubeGeometry(curve, 12, 0.14, 6, false);
          const chord = new THREE.Mesh(geom, mat);
          this.chordaeGroup.add(chord);
        }

        const secondaryCount = 8;
        for (let i = 0; i < secondaryCount; i++) {
          const angle = (i / secondaryCount) * Math.PI * 2;
          const sx = Math.cos(angle) * 4, sz = Math.sin(angle) * 3, sy = -2;
          const ex = Math.cos(angle) * 2, ez = Math.sin(angle) * 1.4, ey = -14;
          const curve = new THREE.CatmullRomCurve3([ new THREE.Vector3(sx, sy, sz), new THREE.Vector3(ex, ey, ez) ]);
          const geom = new THREE.TubeGeometry(curve, 8, 0.18, 6, false);
          const chord = new THREE.Mesh(geom, mat);
          this.chordaeGroup.add(chord);
        }
        this.valveGroup.add(this.chordaeGroup);
      }

      createCalcium() {
        this.calciumGroup.clear();
        const mat = new THREE.MeshStandardMaterial({ color: 0xe8edf2, roughness: 0.35, metalness: 0.15, emissive: 0x111111, emissiveIntensity: 0.05 });
        for (let i = 0; i < 24; i++) {
          const s = Math.random() * 0.35 + 0.05;
          const sphere = new THREE.Mesh(new THREE.SphereGeometry(s, 10, 10), mat);
          const angle = Math.random() * Math.PI * 2;
          const r = 8 + Math.random() * 1.5;
          sphere.position.set(Math.cos(angle) * r, (Math.random() * 1 - 0.5) * 1.0, Math.sin(angle) * r * 0.75);
          this.calciumGroup.add(sphere);
        }
        this.valveGroup.add(this.calciumGroup);
        this.calciumGroup.visible = false;
      }

      createBloodFlowSystem() {
        const N = 6000;
        const geometry = new THREE.BufferGeometry();
        const pos = new Float32Array(N * 3);
        const col = new Float32Array(N * 3);
        const vel = new Float32Array(N * 3);
        const size = new Float32Array(N);

        for (let i = 0; i < N; i++) {
          const i3 = i * 3;
          const radius = Math.random() * 10;
          const theta = Math.random() * Math.PI * 2;
          pos[i3] = Math.cos(theta) * radius;
          pos[i3 + 1] = Math.random() * 24 - 12;
          pos[i3 + 2] = Math.sin(theta) * radius * 0.75;

          // baseline colors
          const t = pos[i3 + 1] / 24 + 0.5;
          col[i3] = 0.82 + t * 0.18;
          col[i3 + 1] = 0.08 + t * 0.12;
          col[i3 + 2] = 0.18 + t * 0.22;

          vel[i3] = (Math.random() - 0.5) * 0.16;
          vel[i3 + 1] = -Math.random() * 0.45 - 0.35;
          vel[i3 + 2] = (Math.random() - 0.5) * 0.16;
          size[i] = Math.random() * 0.35 + 0.12;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(vel, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(size, 1));

        const material = new THREE.ShaderMaterial({
          uniforms: { time: { value: 0 }, opacity: { value: 0.75 } },
          vertexColors: true,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          vertexShader: `
            attribute float size;
            attribute vec3 velocity;
            varying vec3 vColor;
            uniform float time;

            // Cheap curl-like noise for turbulence
            float n(vec3 p){
              return fract(sin(dot(p, vec3(12.9898,78.233,37.719))) * 43758.5453);
            }
            vec3 curl(vec3 p){
              float e = 0.1;
              float n1 = n(p + vec3(0.0, e, 0.0));
              float n2 = n(p - vec3(0.0, e, 0.0));
              float n3 = n(p + vec3(0.0, 0.0, e));
              float n4 = n(p - vec3(0.0, 0.0, e));
              float n5 = n(p + vec3(e, 0.0, 0.0));
              float n6 = n(p - vec3(e, 0.0, 0.0));
              return vec3(n1 - n2, n3 - n4, n5 - n6);
            }

            void main() {
              vColor = color;
              vec3 p = position;

              // add gentle oscillation + curl turbulence
              p.x += sin(time*0.8 + position.y*0.12)*0.35;
              p.z += cos(time*0.7 + position.y*0.1)*0.35;
              p += curl(position*0.05 + time*0.3) * 0.2;

              vec4 mv = modelViewMatrix * vec4(p, 1.0);
              gl_PointSize = size * (300.0 / -mv.z);
              gl_Position = projectionMatrix * mv;
            }
          `,
          fragmentShader: `
            uniform float opacity;
            varying vec3 vColor;
            void main() {
              vec2 c = gl_PointCoord - 0.5;
              float d = length(c);
              float a = 1.0 - smoothstep(0.0, 0.5, d);
              gl_FragColor = vec4(vColor, a * opacity);
            }
          `
        });

        this.bloodParticles = new THREE.Points(geometry, material);
        this.scene.add(this.bloodParticles);
      }

      setupPostProcessing() {
        this.composer = new THREE.EffectComposer(this.renderer);
        this.renderPass = new THREE.RenderPass(this.scene, this.camera);
        this.composer.addPass(this.renderPass);

        // FXAA
        this.fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        const pixelRatio = this.renderer.getPixelRatio();
        const container = document.getElementById('canvas-container');
        this.fxaaPass.material.uniforms['resolution'].value.set(1 / (container.clientWidth * pixelRatio), 1 / (container.clientHeight * pixelRatio));
        this.composer.addPass(this.fxaaPass);

        // Bloom
        this.bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 0.8, 0.6, 0.01);
        this.composer.addPass(this.bloomPass);

        // SSAO
        this.ssaoPass = new THREE.SSAOPass(this.scene, this.camera, container.clientWidth, container.clientHeight);
        this.ssaoPass.kernelRadius = 8;
        this.ssaoPass.minDistance = 0.005;
        this.ssaoPass.maxDistance = 0.2;
        this.composer.addPass(this.ssaoPass);

        // Initialize settings from UI/localStorage
        this.loadRenderSettings();
      }

      // === Charts (SVG) ===
      setupSVGCharts() {
        const makeGrid = (svg) => {
          const g = svg.querySelector('.chart-grid');
          g.innerHTML = '';
          const W = svg.viewBox.baseVal.width, H = svg.viewBox.baseVal.height;
          for (let x = 0; x < W; x += 40) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x); line.setAttribute('y1', 0); line.setAttribute('x2', x); line.setAttribute('y2', H);
            line.setAttribute('class', 'chart-grid-line'); line.setAttribute('stroke', 'rgba(100,150,255,0.1)');
            g.appendChild(line);
          }
          for (let y = 0; y < H; y += 30) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', 0); line.setAttribute('y1', y); line.setAttribute('x2', W); line.setAttribute('y2', y);
            line.setAttribute('stroke', 'rgba(100,150,255,0.1)');
            g.appendChild(line);
          }
        };
        makeGrid(document.getElementById('pressureSVG'));
        makeGrid(document.getElementById('flowSVG'));

        // Export buttons
        const exportSVG = (id, name) => {
          const svg = document.getElementById(id);
          const serializer = new XMLSerializer();
          const source = serializer.serializeToString(svg);
          const blob = new Blob([source], {type: 'image/svg+xml;charset=utf-8'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = `${name}_${Date.now()}.svg`; a.click();
          URL.revokeObjectURL(url);
          this.showNotification('success', 'Export', `${name} SVG exported`);
        };
        document.getElementById('btnExportPressure').addEventListener('click', () => exportSVG('pressureSVG', 'pressure'));
        document.getElementById('btnExportFlow').addEventListener('click', () => exportSVG('flowSVG', 'flow'));
      }

      updateSVGCharts() {
        // Draw simple param models similar to your canvas logic, synced to time.
        const tNow = performance.now() * 0.001;
        const drawPath = (svgId, func) => {
          const svg = document.getElementById(svgId);
          const W = svg.viewBox.baseVal.width, H = svg.viewBox.baseVal.height;
          let d = '';
          for (let x = 0; x <= W; x++) {
            const t = (x / W) * 2 * Math.PI;
            const y = func(tNow, t, W, H);
            d += (x === 0 ? 'M' : 'L') + x + ' ' + y;
          }
          return d;
        };

        // Pressure: LVP & LAP
        const H1 = document.getElementById('pressureSVG').viewBox.baseVal.height;
        const lvpD = drawPath('pressureSVG', (time, tt, W, H) => {
          const phase = (time + tt) % (2 * Math.PI);
          let p;
          if (phase < Math.PI * 0.7) p = 80 + 40 * Math.sin(phase / 0.7);
          else p = 80 * Math.exp(-(phase - Math.PI * 0.7) / 2);
          return H - (p / 140) * H;
        });
        const lapD = drawPath('pressureSVG', (time, tt, W, H) => {
          const phase = (time + tt) % (2 * Math.PI);
          const p = 10 + 5 * Math.sin(phase);
          return H - (p / 140) * H;
        });
        document.getElementById('lvpPath').setAttribute('d', lvpD);
        document.getElementById('lapPath').setAttribute('d', lapD);

        // Flow: transmitral forward + regurgitant (systolic)
        const flowH = document.getElementById('flowSVG').viewBox.baseVal.height;
        const tmfD = drawPath('flowSVG', (time, tt, W, H) => {
          const phase = (time + tt) % (2 * Math.PI);
          let v;
          if (phase < Math.PI * 0.7) v = Math.max(0, -Math.sin(phase / 0.7) * 0.3);
          else {
            const dP = (phase - Math.PI * 0.7) / (Math.PI * 1.3);
            if (dP < 0.4) v = Math.sin(dP / 0.4 * Math.PI) * 1.2;
            else if (dP > 0.7) v = Math.sin((dP - 0.7) / 0.3 * Math.PI) * 0.8;
            else v = 0.1;
          }
          return flowH / 2 - v * flowH / 3;
        });
        const regD = drawPath('flowSVG', (time, tt, W, H) => {
          const phase = (time + tt) % (2 * Math.PI);
          let v = 0;
          if (phase < Math.PI * 0.7) {
            v = -Math.sin(phase / 0.7 * Math.PI) * (this.hemodynamics.regurgitantFraction * 2.0);
          }
          return flowH / 2 - v * flowH / 3;
        });
        document.getElementById('tmfPath').setAttribute('d', tmfD);
        document.getElementById('regPath').setAttribute('d', regD);
      }

      // === Event wiring ===
      setupEventListeners() {
        window.addEventListener('resize', () => this.onWindowResize());
        document.addEventListener('keydown', (e) => this.onKey(e));

        // Header
        document.getElementById('btnImport').addEventListener('click', () => this.importDICOM());
        document.getElementById('btnExport').addEventListener('click', () => this.exportData());
        document.getElementById('btnSim').addEventListener('click', () => this.toggleSimulation());
        document.getElementById('btnXR').addEventListener('click', () => this.toggleAR());
        document.getElementById('btnSettings').addEventListener('click', () => this.showSettings());
        document.getElementById('btnVoice').addEventListener('click', () => this.toggleVoice());

        // Tools
        document.getElementById('btnMeasure').addEventListener('click', () => this.toggleMeasure());
        document.getElementById('btnAnnotate').addEventListener('click', () => this.toggleAnnotate());
        document.getElementById('btnShot').addEventListener('click', () => this.screenshot());
        document.getElementById('btnRecord').addEventListener('click', () => this.toggleRecord());
        document.getElementById('btnFull').addEventListener('click', () => this.toggleFullscreen());

        // Timeline
        document.getElementById('playBtn').addEventListener('click', () => this.togglePlayback());
        document.getElementById('btnPrev').addEventListener('click', () => this.previousFrame());
        document.getElementById('btnNext').addEventListener('click', () => this.nextFrame());
        document.getElementById('btnFast').addEventListener('click', () => this.increaseSpeed());
        document.getElementById('btnSlow').addEventListener('click', () => this.decreaseSpeed());

        // Drag timeline handle
        const track = document.getElementById('timelineTrack');
        const handle = document.getElementById('timelineHandle');
        const onSeek = (clientX) => {
          const rect = track.getBoundingClientRect();
          const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
          this.currentTime = percent * this.cardiacCycle;
          this.updateTimeline();
        };
        track.addEventListener('mousedown', (e) => { this.draggingTimeline = true; onSeek(e.clientX); });
        document.addEventListener('mousemove', (e) => { if (this.draggingTimeline) onSeek(e.clientX); });
        document.addEventListener('mouseup', () => { this.draggingTimeline = false; });

        // Click picking for tools
        const canvas = this.renderer.domElement;
        canvas.addEventListener('pointerdown', (e) => this.onPointerDown(e));
      }

      onKey(e) {
        if (e.code === 'Space') { e.preventDefault(); this.togglePlayback(); }
        if (e.key.toLowerCase() === 'f') this.toggleFullscreen();
        if (e.key.toLowerCase() === 'r') this.resetView();
        if (e.key.toLowerCase() === 'm') this.toggleMeasure();
        if (e.key.toLowerCase() === 'a') this.toggleAnnotate();
        if (e.key === 'ArrowLeft') this.previousFrame();
        if (e.key === 'ArrowRight') this.nextFrame();
        if (e.key === '+' || e.key === '=') this.increaseSpeed();
        if (e.key === '-' || e.key === '_') this.decreaseSpeed();
        // Dev: L toggles rim lights
        if (e.key.toLowerCase() === 'l') { const v = !this.rim1.visible; this.rim1.visible = this.rim2.visible = v; this.showNotification('info', 'Lights', `Rim lights ${v?'on':'off'}`); }
      }

      onWindowResize() {
        const c = document.getElementById('canvas-container');
        this.camera.aspect = c.clientWidth / c.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(c.clientWidth, c.clientHeight);
        this.css2d.setSize(c.clientWidth, c.clientHeight);
        if (this.fxaaPass) {
          const pr = this.renderer.getPixelRatio();
          this.fxaaPass.material.uniforms['resolution'].value.set(1 / (c.clientWidth * pr), 1 / (c.clientHeight * pr));
        }
        if (this.ssaoPass) this.ssaoPass.setSize(c.clientWidth, c.clientHeight);
        if (this.bloomPass) this.bloomPass.setSize(c.clientWidth, c.clientHeight);
      }

      // === Slider wiring (custom UI) ===
      setupSliders() {
        const dragSlider = (handleEl, fillEl, labelEl, onChange) => {
          let dragging = false;
          const container = handleEl.parentElement.parentElement;
          const track = container.querySelector('.slider-track');

          const setPct = (pct) => {
            pct = Math.max(0, Math.min(1, pct));
            handleEl.style.left = (pct * 100) + '%';
            fillEl.style.width = (pct * 100) + '%';
            onChange(pct, labelEl);
          };
          handleEl.addEventListener('mousedown', () => dragging = true);
          document.addEventListener('mouseup', () => dragging = false);
          document.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const r = track.getBoundingClientRect();
            const pct = (e.clientX - r.left) / r.width; setPct(pct);
          });
          track.addEventListener('mousedown', (e) => {
            const r = track.getBoundingClientRect();
            const pct = (e.clientX - r.left) / r.width; setPct(pct);
          });
        };

        // Opacity
        dragSlider(
          document.getElementById('handleOpacity'),
          document.getElementById('fillOpacity'),
          document.getElementById('lblOpacity'),
          (pct, lbl) => {
            const v = Math.round(pct * 100);
            lbl.textContent = v + '%';
            this.leafletMats.forEach(m => m.opacity = 0.2 + 0.8 * pct);
          }
        );

        // Slice (apex→base via clipping plane)
        dragSlider(
          document.getElementById('handleSlice'),
          document.getElementById('fillSlice'),
          document.getElementById('lblSlice'),
          (pct, lbl) => {
            const labels = ['Apex','Mid','Base'];
            const idx = pct < 0.33 ? 0 : (pct < 0.66 ? 1 : 2);
            lbl.textContent = labels[idx];
            // move clipping plane along Y: -10 (apex) to +8 (base)
            const y = -10 + pct * (18);
            this.clippingPlane.set(new THREE.Vector3(0, 1, 0), -y);
          }
        );

        // HR
        dragSlider(
          document.getElementById('handleHR'),
          document.getElementById('fillHR'),
          document.getElementById('lblHR'),
          (pct, lbl) => {
            const hr = 50 + Math.round(pct * (120 - 50));
            this.hemodynamics.heartRate = hr;
            this.cardiacCycle = 60 / hr;
            lbl.textContent = `${hr} bpm`;
          }
        );
        // SBP
        dragSlider(
          document.getElementById('handleSBP'),
          document.getElementById('fillSBP'),
          document.getElementById('lblSBP'),
          (pct, lbl) => {
            const sbp = 90 + Math.round(pct * (160 - 90));
            this.hemodynamics.systolicPressure = sbp;
            lbl.textContent = `${sbp} mmHg`;
          }
        );
      }

      setupLayerToggles() {
        const grid = document.getElementById('layersGrid');
        grid.addEventListener('click', (e) => {
          const btn = e.target.closest('.toggle-btn');
          if (!btn) return;
          btn.classList.toggle('active');
          const layer = btn.getAttribute('data-layer');
          this.toggleLayer(layer, btn.classList.contains('active'));
        });
      }

      toggleLayer(layer, state) {
        switch (layer) {
          case 'tissue':
            this.anteriorLeaflet.visible = state; this.posteriorLeaflet.visible = state;
            break;
          case 'flow':
            if (this.bloodParticles) this.bloodParticles.visible = state;
            break;
          case 'calcium':
            this.calciumGroup.visible = state;
            break;
          case 'annulus':
            if (this.annulusMesh) this.annulusMesh.visible = state;
            break;
          case 'chordae':
            if (this.chordaeGroup) this.chordaeGroup.visible = state;
            break;
          case 'papillary':
            if (this.papGroup) this.papGroup.visible = state;
            break;
        }
        this.showNotification('info', 'Layer', `${layer} ${state ? 'shown' : 'hidden'}`);
      }

      setupScenarios() {
        const grid = document.getElementById('scenarioGrid');
        grid.addEventListener('click', (e) => {
          const card = e.target.closest('.sim-card'); if (!card) return;
          grid.querySelectorAll('.sim-card').forEach(c => c.classList.remove('active'));
          card.classList.add('active');
          const scenario = card.getAttribute('data-scenario');
          this.loadScenario(scenario);
        });
      }

      loadScenario(scenario) {
        const scenarios = {
          'normal':        { regurgitantFraction: 0.0,  heartRate: 70, systolicPressure: 120, diastolicPressure: 80, leftAtrialPressure: 8 },
          'mild-mr':       { regurgitantFraction: 0.15, heartRate: 75, systolicPressure: 125, diastolicPressure: 80, leftAtrialPressure: 10 },
          'moderate-mr':   { regurgitantFraction: 0.30, heartRate: 78, systolicPressure: 130, diastolicPressure: 85, leftAtrialPressure: 15 },
          'severe-mr':     { regurgitantFraction: 0.50, heartRate: 85, systolicPressure: 135, diastolicPressure: 85, leftAtrialPressure: 20 },
          'prolapse':      { regurgitantFraction: 0.35, heartRate: 80, systolicPressure: 130, diastolicPressure: 80, leftAtrialPressure: 18 },
          'stenosis':      { regurgitantFraction: 0.05, heartRate: 90, systolicPressure: 140, diastolicPressure: 90, leftAtrialPressure: 25 },
          'flail':         { regurgitantFraction: 0.60, heartRate: 88, systolicPressure: 125, diastolicPressure: 75, leftAtrialPressure: 22 },
          'repair':        { regurgitantFraction: 0.05, heartRate: 70, systolicPressure: 118, diastolicPressure: 78, leftAtrialPressure: 10 },
          'prosthetic':    { regurgitantFraction: 0.02, heartRate: 72, systolicPressure: 122, diastolicPressure: 80, leftAtrialPressure: 12 }
        };
        const cfg = scenarios[scenario];
        if (cfg) {
          Object.assign(this.hemodynamics, cfg);
          this.cardiacCycle = 60 / this.hemodynamics.heartRate;
          this.showNotification('success', 'Scenario', `${scenario.replace('-', ' ')} activated`);
        }
      }

      setupViews() {
        document.querySelectorAll('.view-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const view = btn.getAttribute('data-view');
            const pos = {
              '3d': { x: 0, y: 15, z: 40 },
              '4ch': { x: 0, y: 0, z: 55 },
              'lax': { x: 55, y: 0, z: 0 },
              'sax': { x: 0, y: 55, z: 0 }
            }[view];
            if (pos) {
              this.camera.position.set(pos.x, pos.y, pos.z);
              this.camera.lookAt(0, 0, 0);
            }
          });
        });
      }

      // === Animation ===
      animate() {
        this.animationId = requestAnimationFrame(() => this.animate());
        const dt = this.clock.getDelta();
        const t = this.clock.getElapsedTime();

        if (this.controls) this.controls.update();

        // Valve animation
        if (this.isPlaying) {
          this.currentTime += dt * this.speed;
          this.animateValve();
          this.updateTimeline();
          this.updateSimulation();
        }

        // Subtle rotation
        this.valveGroup.rotation.y += 0.001;

        // Metrics + charts
        this.updateMetrics();
        this.updateSVGCharts();

        // Coordinates + FPS
        this.updateHUD();

        // Render with composer
        if (this.composer) this.composer.render();
        else this.renderer.render(this.scene, this.camera);

        // Labels
        if (this.labelRendererReady) this.css2d.render(this.scene, this.camera);
      }

      animateValve() {
        const time = this.clock.getElapsedTime();
        const cycleT = (this.currentTime % this.cardiacCycle);
        const phase = cycleT / this.cardiacCycle;
        const systole = phase < 0.35;

        const animateLeaf = (group, isAnterior) => {
          if (!group || !group.children.length) return;
          const mesh = group.children[0];
          if (!mesh || !mesh.isMesh) return;
          if (systole) {
            const k = phase / 0.35;
            mesh.rotation.x = (isAnterior ? -1 : 1) * (0.28 * k);
            mesh.position.y = (isAnterior ? 2.0 : 1.4) * k;
          } else {
            const k = (phase - 0.35) / 0.65;
            mesh.rotation.x = (isAnterior ? -0.28 : 0.28) + (isAnterior ? 0.28 : -0.28) * k;
            mesh.position.y = (isAnterior ? 2.0 : 1.4) - (isAnterior ? 2.0 : 1.4) * k;
          }

          // tiny vertex jitter for living tissue feel
          const geo = mesh.geometry; const arr = geo.attributes.position.array;
          for (let i = 0; i < arr.length; i += 3) {
            const ox = arr[i], oy = arr[i+1], oz = arr[i+2];
            arr[i+1] = oy + Math.sin(time*3 + i*0.01) * 0.02 * (systole ? 1.0 : 0.4);
          }
          geo.attributes.position.needsUpdate = true;
          geo.computeVertexNormals();
        };

        if (document.getElementById('chkAnimateCoaptation')?.checked) {
          animateLeaf(this.anteriorLeaflet, true);
          animateLeaf(this.posteriorLeaflet, false);
        }

        // Chordae pulsation
        this.chordaeGroup.children.forEach((chord, idx) => {
          const tension = systole ? 1.18 : 1.0;
          chord.scale.y = tension + Math.sin(time*3 + idx)*0.03;
        });

        // Flow dynamics: regurgitant accent in systole
        if (this.bloodParticles) {
          const pos = this.bloodParticles.geometry.attributes.position.array;
          const vel = this.bloodParticles.geometry.attributes.velocity.array;
          const col = this.bloodParticles.geometry.attributes.color.array;
          for (let i = 0; i < pos.length; i += 3) {
            pos[i] += vel[i];
            pos[i+1] += vel[i+1];
            pos[i+2] += vel[i+2];

            if (systole && pos[i+1] > 0) {
              pos[i] += (Math.random()-0.5)*0.28;
              pos[i+2] += (Math.random()-0.5)*0.28;
              vel[i+1] = Math.abs(vel[i+1]) * (1.2 + this.hemodynamics.regurgitantFraction);
              col[i] = 1.0; col[i+1] = 0.85; col[i+2] = 0.0;
            } else {
              col[i] = 0.82; col[i+1] = 0.1; col[i+2] = 0.2;
            }

            if (Math.abs(pos[i+1]) > 22) {
              const r = Math.random()*10, th = Math.random()*Math.PI*2;
              pos[i] = Math.cos(th)*r; pos[i+1] = systole ? -12 : 12; pos[i+2] = Math.sin(th)*r*0.75;
              vel[i] = (Math.random()-0.5)*0.16; vel[i+1] = systole ? Math.random()*0.45 : -Math.random()*0.45; vel[i+2] = (Math.random()-0.5)*0.16;
            }
          }
          this.bloodParticles.geometry.attributes.position.needsUpdate = true;
          this.bloodParticles.geometry.attributes.color.needsUpdate = true;
          this.bloodParticles.material.uniforms.time.value = time;
          this.bloodParticles.visible = document.getElementById('chkBloodFlow')?.checked;
        }
      }

      updateTimeline() {
        const cycleT = this.currentTime % this.cardiacCycle;
        const phase = cycleT / this.cardiacCycle;
        document.getElementById('currentTime').textContent = cycleT.toFixed(3);
        document.getElementById('totalTime').textContent = this.cardiacCycle.toFixed(3);
        const pct = phase * 100;
        document.getElementById('timelineProgress').style.width = pct + '%';
        document.getElementById('timelineHandle').style.left = pct + '%';

        const diastole = document.getElementById('diastole');
        const systole  = document.getElementById('systole');
        const iso      = document.getElementById('isovolumetric');
        diastole.classList.remove('active'); systole.classList.remove('active'); iso.classList.remove('active');
        if (phase < 0.1) iso.classList.add('active');
        else if (phase < 0.35) systole.classList.add('active');
        else if (phase < 0.45) iso.classList.add('active');
        else diastole.classList.add('active');
      }

      updateSimulation() {
        const phase = (this.currentTime % this.cardiacCycle) / this.cardiacCycle;
        let ap, vp;
        if (phase < 0.35) {
          vp = this.hemodynamics.diastolicPressure + (this.hemodynamics.systolicPressure - this.hemodynamics.diastolicPressure) * Math.sin(phase/0.35 * Math.PI/2);
          ap = this.hemodynamics.leftAtrialPressure + 5 * Math.sin(phase/0.35 * Math.PI);
        } else {
          const d = (phase - 0.35) / 0.65;
          vp = this.hemodynamics.systolicPressure * Math.exp(-d*3) + this.hemodynamics.diastolicPressure;
          ap = this.hemodynamics.leftAtrialPressure * (1 + 0.3 * Math.sin(d * Math.PI));
        }
        const dp = Math.max(0, vp - ap);
        const vReg = Math.sqrt(2 * dp / 1.06);
        const volReg = this.hemodynamics.regurgitantFraction * this.hemodynamics.strokeVolume * Math.max(0, Math.sin(phase * Math.PI));

        document.getElementById('mrVolume').textContent = Math.max(0, volReg).toFixed(1);
        document.getElementById('eroa').textContent = (this.hemodynamics.regurgitantFraction * 0.4 + Math.sin(performance.now()*0.002) * 0.02).toFixed(2);
        document.getElementById('peakVel').textContent = vReg.toFixed(1);
        document.getElementById('meanGrad').textContent = (dp * 0.4).toFixed(1);
      }

      updateMetrics() {
        const mr = parseFloat(document.getElementById('mrVolume').textContent);
        const eroa = parseFloat(document.getElementById('eroa').textContent);
        const setInd = (el, level) => { el.className = 'metric-indicator' + (level?' '+level:''); };
        setInd(document.getElementById('indMR'), mr > 30 ? 'danger' : (mr > 15 ? 'warning' : ''));
        setInd(document.getElementById('indEROA'), eroa > 0.4 ? 'danger' : (eroa > 0.2 ? 'warning' : ''));
      }

      updateHUD() {
        const p = this.camera.position;
        document.getElementById('coordX').textContent = p.x.toFixed(2);
        document.getElementById('coordY').textContent = p.y.toFixed(2);
        document.getElementById('coordZ').textContent = p.z.toFixed(2);
        // FPS
        if (!this._fpsLast) { this._fpsLast = performance.now(); this._fpsFrames = 0; }
        this._fpsFrames++;
        const now = performance.now();
        if (now - this._fpsLast > 1000) {
          const fps = Math.round(this._fpsFrames * 1000 / (now - this._fpsLast));
          document.getElementById('fps').textContent = fps;
          this._fpsLast = now; this._fpsFrames = 0;
        }
      }

      // === Tools ===
      onPointerDown(e) {
        if (!this.isMeasuring && !this.isAnnotating) return;
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        this.pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        this.raycaster.setFromCamera(this.pointer, this.camera);
        const hits = this.raycaster.intersectObjects([ this.anteriorLeaflet.children[0], this.posteriorLeaflet.children[0] ], true);
        if (!hits.length) return;

        const point = hits[0].point.clone();
        if (this.isMeasuring) this.addMeasurePoint(point);
        if (this.isAnnotating) this.addAnnotation(point);
      }

      toggleMeasure() {
        this.isMeasuring = !this.isMeasuring; if (this.isMeasuring) this.isAnnotating = false;
        document.getElementById('btnMeasure').classList.toggle('active', this.isMeasuring);
        this.showNotification('info', 'Measurement', this.isMeasuring ? 'Click leaflet to place points' : 'Measurement off');
        if (!this.isMeasuring) this.measurePoints = [];
      }

      addMeasurePoint(p) {
        // sphere marker
        const s = new THREE.Mesh(new THREE.SphereGeometry(0.3, 12, 12), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
        s.position.copy(p); this.measureGroup.add(s);
        this.measurePoints.push(p.clone());
        if (this.measurePoints.length >= 2) {
          const a = this.measurePoints[this.measurePoints.length - 2];
          const b = this.measurePoints[this.measurePoints.length - 1];
          const dist = a.distanceTo(b);
          const mm = (dist * 1.0).toFixed(2) + ' mm'; // 1 unit ≈ 1 mm (for demo)
          const line = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([a, b]),
            new THREE.LineDashedMaterial({ color: 0x00ffff, dashSize: 0.5, gapSize: 0.25 })
          );
          line.computeLineDistances(); this.measureGroup.add(line);

          // mid label
          const mid = a.clone().lerp(b, 0.5);
          const div = document.createElement('div');
          div.style.padding = '4px 6px'; div.style.background = 'rgba(0,0,0,.6)';
          div.style.border = '1px solid rgba(0,255,255,.5)'; div.style.borderRadius = '6px';
          div.style.color = '#aef'; div.style.fontSize = '12px'; div.textContent = mm;
          const label = new THREE.CSS2DObject(div); label.position.copy(mid);
          this.measureGroup.add(label);

          // angle if 3rd point
          if (this.measurePoints.length >= 3) {
            const c = this.measurePoints[this.measurePoints.length - 3];
            const v1 = new THREE.Vector3().subVectors(a, c).normalize();
            const v2 = new THREE.Vector3().subVectors(b, a).normalize();
            const ang = Math.acos(THREE.Math.clamp(v1.dot(v2), -1, 1)) * 180 / Math.PI;
            const div2 = document.createElement('div');
            div2.style.padding = '4px 6px'; div2.style.background = 'rgba(0,0,0,.6)';
            div2.style.border = '1px solid rgba(255,255,0,.5)'; div2.style.borderRadius = '6px';
            div2.style.color = '#ff8'; div2.style.fontSize = '12px'; div2.textContent = `Angle ${ang.toFixed(1)}°`;
            const label2 = new THREE.CSS2DObject(div2); label2.position.copy(a);
            this.measureGroup.add(label2);
          }
        }
      }

      toggleAnnotate() {
        this.isAnnotating = !this.isAnnotating; if (this.isAnnotating) this.isMeasuring = false;
        document.getElementById('btnAnnotate').classList.toggle('active', this.isAnnotating);
        this.showNotification('info', 'Annotation', this.isAnnotating ? 'Click leaflet to add labels' : 'Annotation off');
      }

      addAnnotation(p) {
        const div = document.createElement('div');
        div.style.padding = '6px 8px'; div.style.background = 'rgba(20,25,45,.9)';
        div.style.border = '1px solid rgba(100,150,255,.4)'; div.style.borderRadius = '8px'; div.style.color = '#dbe6ff';
        div.style.fontSize = '12px'; div.style.pointerEvents = 'auto'; div.textContent = 'Note';
        div.contentEditable = 'true';
        const label = new THREE.CSS2DObject(div);
        label.position.copy(p);
        this.annotationGroup.add(label);
        this.showNotification('success', 'Annotation', 'Label added — click to edit');
      }

      screenshot() {
        const dataURL = this.renderer.domElement.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = `mitral_valve_${Date.now()}.png`;
        link.href = dataURL; link.click();
        this.showNotification('success', 'Screenshot', 'Image saved');
      }

      toggleRecord() {
        if (!this.isRecording) {
          const stream = this.renderer.domElement.captureStream(60);
          this.recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
          this.recordChunks = [];
          this.recorder.ondataavailable = e => { if (e.data.size) this.recordChunks.push(e.data); };
          this.recorder.onstop = () => {
            const blob = new Blob(this.recordChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `mitral_record_${Date.now()}.webm`; a.click();
            URL.revokeObjectURL(url);
          };
          this.recorder.start();
          this.isRecording = true;
          document.getElementById('btnRecord').classList.add('active');
          this.showNotification('warning', 'Recording', 'Recording started');
        } else {
          this.recorder?.stop();
          this.isRecording = false;
          document.getElementById('btnRecord').classList.remove('active');
          this.showNotification('success', 'Recording', 'Recording saved');
        }
      }

      toggleFullscreen() {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
      }

      resetView() {
        this.camera.position.set(0, 15, 40);
        this.camera.lookAt(0, 0, 0);
        this.valveGroup.rotation.set(0, 0, 0);
      }

      togglePlayback() {
        this.isPlaying = !this.isPlaying;
        document.getElementById('playBtn').textContent = this.isPlaying ? '❚❚' : '▶';
      }
      previousFrame() { this.currentTime = Math.max(0, this.currentTime - 0.016); this.updateTimeline(); }
      nextFrame() { this.currentTime += 0.016; this.updateTimeline(); }
      increaseSpeed() { this.speed = Math.min(4, this.speed * 1.5); document.getElementById('speedText').textContent = `${this.speed < 1 ? this.speed.toFixed(1) : this.speed.toFixed(0)}×`; }
      decreaseSpeed() { this.speed = Math.max(0.25, this.speed / 1.5); document.getElementById('speedText').textContent = `${this.speed < 1 ? this.speed.toFixed(1) : this.speed.toFixed(0)}×`; }
      toggleSimulation() { this.togglePlayback(); }

      toggleAR() {
        try {
          if ('xr' in navigator) {
            this.renderer.xr.enabled = true;
            const btnAR = window.ARButton ? ARButton.createButton(this.renderer, { requiredFeatures: [] }) : null;
            const btnVR = window.VRButton ? VRButton.createButton(this.renderer) : null;
            if (btnAR) { document.body.appendChild(btnAR); btnAR.click(); this.showNotification('info', 'AR', 'Attempting to start AR session'); }
            else if (btnVR) { document.body.appendChild(btnVR); btnVR.click(); this.showNotification('info', 'VR', 'Attempting to start VR session'); }
            else this.showNotification('warning', 'WebXR', 'XR buttons not available in this build');
          } else this.showNotification('warning', 'WebXR', 'WebXR not supported');
        } catch (err) {
          console.error(err); this.showNotification('error', 'WebXR', 'Failed to start XR');
        }
      }

      // === DICOM ===
      async importDICOM() {
        const input = document.createElement('input');
        input.type = 'file'; input.multiple = true; input.accept = '.dcm,application/dicom';
        input.onchange = async (e) => {
          const files = Array.from(e.target.files || []);
          if (!files.length) return;
          this.showNotification('info', 'Import', `Importing ${files.length} DICOM file(s)`);
          let firstDataset = null;
          for (const f of files) {
            try {
              const buf = await f.arrayBuffer();
              const dicomData = dcmjs.data.DicomMessage.readFile(buf);
              const dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(dicomData.dict);
              if (!firstDataset) firstDataset = dataset;
            } catch (err) {
              console.warn('DICOM parse failed', err);
            }
          }
          if (firstDataset) {
            const name = firstDataset.PatientName || 'Unknown';
            const id = firstDataset.PatientID || 'N/A';
            const sex = firstDataset.PatientSex || 'U';
            const age = firstDataset.PatientAge ? firstDataset.PatientAge.replace(/^0+/, '') : '—';
            document.getElementById('patientName').textContent = typeof name === 'object' ? (name.Alphabetic || JSON.stringify(name)) : name;
            document.getElementById('patientId').textContent = `ID: ${id}`;
            document.getElementById('patientSex').textContent = sex === 'F' ? 'Female' : sex === 'M' ? 'Male' : 'Unk';
            document.getElementById('patientAge').textContent = age.toLowerCase().endsWith('y') ? age : (age ? `${age}y` : '—');
            // Safe defaults: keep your sample hemodynamics; DICOM echo volumes would require segmentation (out of scope here).
            this.showNotification('success', 'DICOM', 'Patient metadata imported');
          } else {
            this.showNotification('warning', 'DICOM', 'No readable DICOM metadata found');
          }
        };
        input.click();
      }

      exportData() {
        const data = {
          timestamp: new Date().toISOString(),
          hemodynamics: this.hemodynamics,
          metrics: {
            mrVolume: document.getElementById('mrVolume').textContent,
            eroa: document.getElementById('eroa').textContent,
            peakVelocity: document.getElementById('peakVel').textContent,
            meanGradient: document.getElementById('meanGrad').textContent
          }
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url; link.download = `mitral_data_${Date.now()}.json`; link.click();
        URL.revokeObjectURL(url);
        this.showNotification('success', 'Export', 'Data exported successfully');
      }

      // === Settings persist ===
      loadRenderSettings() {
        const ls = JSON.parse(localStorage.getItem('mv_settings') || '{}');
        const byId = (id, def) => (ls[id] ?? def);
        const setChecked = (id, def) => { const el = document.getElementById(id); if (el) { el.checked = byId(id, def); } };
        setChecked('chkBloom', true);
        setChecked('chkSSAO', true);
        setChecked('chkFXAA', true);
        setChecked('chkAnimateCoaptation', true);
        setChecked('chkBloodFlow', true);
        setChecked('chkRimLights', true);
        const rng = document.getElementById('rngBloom'); if (rng) rng.value = (ls['rngBloom'] ?? 0.8);
        const lbl = document.getElementById('lblBloom'); if (lbl) lbl.textContent = parseFloat(rng.value).toFixed(2);

        // Apply toggles
        this.bloomPass.enabled = document.getElementById('chkBloom').checked;
        this.ssaoPass.enabled  = document.getElementById('chkSSAO').checked;
        this.fxaaPass.enabled  = document.getElementById('chkFXAA').checked;
        const v = document.getElementById('chkRimLights').checked; this.rim1.visible = this.rim2.visible = v;

        document.getElementById('rngBloom').addEventListener('input', (e) => {
          const v = parseFloat(e.target.value); this.bloomPass.strength = v; document.getElementById('lblBloom').textContent = v.toFixed(2);
          this.saveRenderSettings();
        });
        ['chkBloom','chkSSAO','chkFXAA','chkAnimateCoaptation','chkBloodFlow','chkRimLights'].forEach(id => {
          document.getElementById(id).addEventListener('change', () => {
            this.bloomPass.enabled = document.getElementById('chkBloom').checked;
            this.ssaoPass.enabled  = document.getElementById('chkSSAO').checked;
            this.fxaaPass.enabled  = document.getElementById('chkFXAA').checked;
            const v = document.getElementById('chkRimLights').checked; this.rim1.visible = this.rim2.visible = v;
            this.saveRenderSettings();
          });
        });
        document.getElementById('btnResetSettings').addEventListener('click', () => { localStorage.removeItem('mv_settings'); this.loadRenderSettings(); this.showNotification('success','Settings','Reset to defaults'); });
      }

      saveRenderSettings() {
        const obj = {
          chkBloom: document.getElementById('chkBloom').checked,
          chkSSAO: document.getElementById('chkSSAO').checked,
          chkFXAA: document.getElementById('chkFXAA').checked,
          chkAnimateCoaptation: document.getElementById('chkAnimateCoaptation').checked,
          chkBloodFlow: document.getElementById('chkBloodFlow').checked,
          chkRimLights: document.getElementById('chkRimLights').checked,
          rngBloom: parseFloat(document.getElementById('rngBloom').value)
        };
        localStorage.setItem('mv_settings', JSON.stringify(obj));
      }

      showSettings() { document.getElementById('settingsModal').classList.add('active'); }

      // === Voice Assistant ===
      toggleVoice() {
        if (this.voiceActive) { this.stopVoice(); return; }
        this.startVoice();
      }
      startVoice() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
          this.showNotification('warning','Voice','Speech recognition unsupported'); return;
        }
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        this.recognition = new SR(); this.recognition.lang = 'en-US'; this.recognition.continuous = true; this.recognition.interimResults = false;
        this.recognition.onresult = (ev) => {
          const t = ev.results[ev.results.length - 1][0].transcript.trim().toLowerCase();
          this.handleVoiceCommand(t);
        };
        this.recognition.onerror = () => this.showNotification('error','Voice','Recognition error');
        this.recognition.onend = () => { if (this.voiceActive) this.recognition.start(); }; // auto-restart
        this.recognition.start();
        this.voiceActive = true;
        document.getElementById('micIndicator').classList.add('mic-on');
        this.speak('Voice assistant online. Say: play simulation, pause simulation, load severe, increase speed, toggle measurement, read metrics.');
      }
      stopVoice() {
        this.voiceActive = false; document.getElementById('micIndicator').classList.remove('mic-on');
        try { this.recognition?.stop(); } catch {}
        this.speak('Voice assistant disabled.');
      }
      speak(text) { try { window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.rate = 1.0; speechSynthesis.speak(u); } catch {} }
      handleVoiceCommand(cmd) {
        const say = (m) => { this.showNotification('info','Voice',m); this.speak(m); };
        if (/play|resume/.test(cmd)) { if (!this.isPlaying) this.togglePlayback(); say('Playing'); return; }
        if (/pause|stop/.test(cmd)) { if (this.isPlaying) this.togglePlayback(); say('Paused'); return; }
        if (/increase speed|faster/.test(cmd)) { this.increaseSpeed(); say(`Speed ${document.getElementById('speedText').textContent}`); return; }
        if (/decrease speed|slower/.test(cmd)) { this.decreaseSpeed(); say(`Speed ${document.getElementById('speedText').textContent}`); return; }
        if (/toggle measure|measurement/.test(cmd)) { this.toggleMeasure(); say('Toggled measurement tool'); return; }
        if (/toggle annotate|annotation/.test(cmd)) { this.toggleAnnotate(); say('Toggled annotation tool'); return; }
        if (/load (normal|mild|moderate|severe|prolapse|stenosis|flail|repair|prosthetic)/.test(cmd)) {
          const map = { normal:'normal','mild':'mild-mr','moderate':'moderate-mr','severe':'severe-mr','prolapse':'prolapse','stenosis':'stenosis','flail':'flail','repair':'repair','prosthetic':'prosthetic' };
          const key = cmd.match(/load (.+)/)[1].split(' ')[0];
          const sc = map[key] || 'normal'; this.loadScenario(sc); say(`Loaded ${key}`);
          return;
        }
        if (/read metrics|what is mr volume|metrics/.test(cmd)) {
          const mr = document.getElementById('mrVolume').textContent;
          const eroa = document.getElementById('eroa').textContent;
          const pv = document.getElementById('peakVel').textContent;
          const mg = document.getElementById('meanGrad').textContent;
          this.speak(`Current M R volume ${mr} milliliters per beat. E R O A ${eroa} square centimeters. Peak velocity ${pv} meters per second. Mean gradient ${mg} millimeters of mercury.`);
          return;
        }
        if (/set view (3d|four|4|long|short)/.test(cmd)) {
          if (/3d/.test(cmd)) document.querySelector('.view-btn[data-view="3d"]').click();
          else if (/four|4/.test(cmd)) document.querySelector('.view-btn[data-view="4ch"]').click();
          else if (/long/.test(cmd)) document.querySelector('.view-btn[data-view="lax"]').click();
          else if (/short/.test(cmd)) document.querySelector('.view-btn[data-view="sax"]').click();
          say('View changed'); return;
        }
        if (/(hide|show) flow/.test(cmd)) {
          const btn = document.querySelector('.toggle-btn[data-layer="flow"]');
          const wantShow = /show/.test(cmd);
          if (!!btn.classList.contains('active') !== wantShow) btn.click();
          say(`${wantShow ? 'Showing' : 'Hiding'} flow`); return;
        }
        this.showNotification('info','Voice',`Heard: "${cmd}"`);
      }

      // === Notifications & errors ===
      showNotification(type, title, message) {
        const container = document.getElementById('notifications');
        const box = document.createElement('div');
        box.className = `notification ${type}`;
        box.innerHTML = `
          <div class="notification-icon">${type === 'success' ? '✓' : type === 'warning' ? '!' : (type === 'error' ? '⛔' : 'ℹ')}</div>
          <div class="notification-content">
            <div class="notification-title">${title}</div>
            <div class="notification-message">${message}</div>
          </div>
          <div class="notification-close" title="Close">✕</div>
        `;
        box.querySelector('.notification-close').addEventListener('click', () => box.remove());
        container.appendChild(box);
        setTimeout(() => { if (box.parentElement) box.remove(); }, 6000);
      }

      showError(message) {
        const container = document.getElementById('canvas-container');
        container.innerHTML = `
          <div class="error-message">
            <div class="error-title">Error</div>
            <div class="error-description">${message}</div>
          </div>
        `;
      }

      // === Background particles ===
      createParticlesBackground() {
        const container = document.getElementById('particles');
        for (let i = 0; i < 50; i++) {
          const el = document.createElement('div');
          el.className = 'particle';
          el.style.left = (Math.random()*100) + '%';
          el.style.animationDelay = (Math.random()*20) + 's';
          el.style.animationDuration = (15 + Math.random()*10) + 's';
          container.appendChild(el);
        }
      }
    }

    // ================== Bootstrap ======================
    let app = null;
    document.addEventListener('DOMContentLoaded', () => {
      try {
        app = new MitralValveApp();
        app.isPlaying = true;
        document.getElementById('playBtn').textContent = '❚❚';
        // Show a quick mini-tour notification
        app.showNotification('info', 'Welcome', 'Drag to orbit, wheel to zoom. Try scenarios, layers, and the 🎙️ Voice Assistant.');
      } catch (err) {
        console.error(err);
        document.getElementById('canvas-container').innerHTML = `
          <div class="error-message">
            <div class="error-title">Initialization Error</div>
            <div class="error-description">Failed to start the application. Please refresh the page.</div>
          </div>
        `;
      }
    });

    // Perf monitor (safe)
    if (window.performance && window.performance.memory) {
      setInterval(() => {
        const m = window.performance.memory;
        const used = Math.round(m.usedJSHeapSize / 1048576);
        const total = Math.round(m.totalJSHeapSize / 1048576);
        console.log(`Memory: ${used}MB / ${total}MB`);
      }, 10000);
    }
  </script>
</body>
</html>
